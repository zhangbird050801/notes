---
tags:
  - 计算机网络
---

RDT: reliable data transfer protocal
## 传输服务和协议
为运行在不同主机上的应用进程提供逻辑通信，提供进程到进程之间的服务。
传输协议运行在端系统。发送方将应用层的报文分成报文段，然后传递给网络层。接收方将报文段重组成报文，然后传递给应 用层。
传输层协议包括 TCP、UDP。
## 传输层和网络层的对比
![|675](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250201201741.png)

传输层<font color="#c00000">无法加强</font><u>带宽、延迟</u>。

Ann 给 Bill 家寄信，一共 144 封信，而寄信有一定费用，所以 Ann 家老大把他们的信都收集起来 (复用) 放到邮箱，从 Ann 邮箱寄到 Bill 家邮箱相当于网络层这种服务，而 Bill 家收到之后，Bill 家老大负责将一大包信分发给老一、老二... (解复用)，此时类似于传输层。

```ad-quote
- 将端到端的网络层协议扩展到进程到进程的传输层协议称为复用和解复用。复用和解复用是所有计算机网络都需要的。
- 每个传输层段中都有一组信息，接收端主机传输层检查这些信息，将这些段直接传送给相应的 socket，这个过程称为**解复用** 。在源端主机中，从不同的socket中将数据片收集起来，加上头部信息封装成段，并且将段传送给网络层称为**复用**。
```

## Internet 传输层协议
- 可靠的、保序的传输：*TCP*
	- 多路复用、解复用
	- 拥塞控制 
	- 流量控制 
	- 建立连接
	- 字节流
- 不可靠、不保序的传输：*UDP* 
	- 多路复用、解复用 
	- 没有为尽力而为的 IP 服务添加更多的其它额外服务
	- 数据报
- 都不提供的服务： 
	- 延时保证 
	- 带宽保证

## 多路复用和解复用
在发送方主机多路复用: 从多个套接字接收来自多个进程的报文，根据套接字对应的 IP 地址和端口号等信息对报文段用头部加以封装(该头部信息用于以后的解复用)。
在接收方主机多路解复用: 根据报文段的头部信息中的 IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)。

### 多路解复用工作原理
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250201223719.png)

### 无连接 UDP 多路解复用
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250201223844.png)
当主机接收到UDP段时：检查UDP段中的目标端口号，将UDP段交给具备那个端口号的套接字。

```ad-note
如果多个UDP数据报具有相同的目标IP地址和目标端口号，即使它们的源IP地址或源端口号不同，这些数据报也会被传递到同一个目标UDP套接字上。
```

### 面向连接 TCP 的多路复用
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250201224309.png)

## UDP
UDP：User Datagram Protocol \[RFC 768\] 用户数据报协议。
报文可能会丢失、乱序。
无连接: UDP发送端和接收端之间没有握手、每个UDP报文段都被独立地处理。UDP 被用于流媒体(丢失不敏感， 速率敏感、应用可控制传输速率)、DNS、SNMP

![|575](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250201222213.png)
### UDP 校验和
目标：检测在被传输报文段中的差错(如比特反转)

- 发送方：
	- 将报文段的内容视为16 比特的整数 
	- 校验和：报文段的加法和（1的补运算） 
	- 发送方将校验和放在 UDP的校验和字段
- 接收方：
	- 计算接收到的报文段的校验和 
	- 检查计算出的校验和与校验和字段的内容是否相等： 
		- 不相等–--检测到差错 
		- 相等–--没有检测到差错 ，但也许还是有差错->**残存错误**

例子：
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250201223540.png)

## RDT 可靠数据传输
### Rdt1.0：在可靠信道上的可靠数据传输
下层的信道是完全可靠的 
	没有比特出错 
	没有分组丢失 
发送方和接收方的 FSM (有限状态机) 
	发送方将数据发送到下层信道 
	接收方从下层信道接收数据
	
### Rdt2.0：具有比特差错的信道
下层信道可能会出错：将分组中的比特翻转。用校验和来检测比特差错。
确认(ACK)：接收方显式地告诉发送方分组已被正确接收 
否定确认(NAK): 接收方显式地告诉发送方分组发生了差错。发送方收到NAK后，发送方重传分组

如果ACK/NAK出错？ -> 发送方就不知道接收方到底要他重传还是不重传，此时要引入新的机制：序号。如果出错了，接收发不管发送方本来是 ACK 还是 NAK，都选择重发上一个分组，携带了序号，所以接收方可以知道这个序号。

处理重复： 
	发送方在每个分组中加入序号 
	如果ACK/NAK出错，发送方重传当前分组 
	接收方丢弃（不发给上层）重复分组 

Stop and wait 停等协议：发送方发送一个分组，然后等待接收方的应答

### Rdt2.1
发送方： 
	在分组中加入序列号。两个序列号（0，1）就足够了，一次只发送一个未经确认的分组 
	必须检测 ACK/NAK 是否出错（需要EDC） 
	状态数变成了两倍 
	必须记住当前分组的序列号为 0 还是 1
接收方： 
	必须检测接收到的分组是否是重复的 
	状态会指示希望接收到的分组的序号为0还是1

接收方并不知道发送方是否正确收到了其 ACK/NAK
#### 发送方处理出错的ACK/NAK
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250205164902.png)
#### 接收方处理出错的ACK/NAK
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250205165059.png)
#### Rdt2.1 的运行
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250205182436.png)

### Rdt2.2: 无 NAK 的协议
只使用 ACK。接收方对最后正确接收的分组发 ACK，以替代 NAK，接收方必须显式地包含被正确接收分组的序号。
当收到重复的 ACK（如：再次收到 ack0）时，发送方与收到 NAK 采取相同的动作：重传当前分组。
#### rdt2.2 的运行
![|575](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250205192320.png)

![|525](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250205193126.png)

### Rdt3.0：具有比特差错和分组丢失的信道
新的假设：
- 下层信道可能会丢失分组（数据 或 ACK）

解决方法：
- 需要发送方等待 ACK 一段合理的时间 
- 发送端超时重传：如果到时没有收到 ACK -> 重传 

问题：
- 如果分组（或ACK）只是被延迟了： 重传将会导致数据重复，但利用序列号已经可以处理这个问题 
- 接收方必须指明被正确接收的序列号 

需要一个倒计数定时器
#### Rdt3.0 运行
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250205194229.png)

![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250205194329.png)

## 流水线协议
流水线：允许发送方在未得到对方确认的情况下一次发送多个分组 
- 必须增加序号的范围: 用多个 bit 表示分组的序号 
- 在发送方/接收方要有缓冲区 
	- 发送方缓冲：未得到确认，可能需要重传；发送方发送完毕之后，把分组放在缓冲区，便于减速重发、超时重发。
	- 接收方缓存：上层用户取用数据的速率 ≠ 接收到的数据速率；接收到的数据可能乱序，排序交付（可靠）

两种通用的流水线协议：回退 N 步(GBN) 和 选择重传(SR)


-tx-
| 发送窗口 | 接收窗口 |                  |       |
| ---- | ---- | ---------------- | ----- |
| SW=1 | RW=1 | stop and wait 协议 |       |
| SW>1 | RW=1 | Go Back N (GBN)            | 流水线协议 |
| SW>1 | RW>1 | Selective Repeat (SR)               | ^^ 

## 滑动窗口(slide window)协议
- 发送缓冲区 
	- 形式：内存中的一个区域，落入缓冲区的分组可以发送 
	- 功能：用于存放已发送，但是没有得到确认的分组 
	- 必要性：需要重发时可用
	- 发送缓冲区的大小：一次最多可以发送多少个未经确认的分组 
		- 停止等待协议 = 1 
		- 流水线协议 > 1，合理的值，不能很大，链路利用率不能够超 100% 
	- 发送缓冲区中的分组 
		- <font color="#c00000">未发送的</font>：落入发送缓冲区的分组，可以连续发送出去
		- <font color="#1f497d">已经发送出去的、等待对方确认的分组</font>：发送缓冲区的分组只有得到确认才能删除

<br>

- 发送窗口：发送缓冲区内容的一个范围，指的是那些已发送但是未经确认分组的序号构成的空间。发送窗口的最大值 <= 发送缓冲区的值。

![|500](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250207151257.png)

- 发送窗口后沿移动
	- 条件：收到老分组的确认 
	- 结果：发送缓冲区罩住新的分组，来了分组可以发送 
	- 移动的极限：不能够超过前沿

<br>

- 接收窗口
	- 接收窗口(receiving window) = 接收缓冲区 
	- 接收窗口用于控制哪些分组可以接收； 
		- 只有收到的分组序号落入接收窗口内才允许接收 
		- 若序号在接收窗口之外，则丢弃； 
		- 接收窗口尺寸 Wr = 1，则只能顺序接收； 
		- 接收窗口尺寸 Wr > 1，则可以乱序接收。但提交给上层的分组，要按序
	- 接收窗口的滑动和发送确认 
		- 滑动：
			- 低序号的分组到来，接收窗口移动； 
			- 高序号分组乱序到，缓存但不交付（因为要实现rdt，不允许失序），不滑动 
		- 发送确认： 
			- 接收窗口尺寸 = 1 ；发送连续收到的最大的分组确认（累计确认） 
			- 接收窗口尺寸 > 1 ；收到分组，发送那个分组的确认（非累计确认）

![|525](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250207153047.png)
GBN 协议中对顺序到来的最高分组进行确认，发送的是累积的确认，意味着这个序号和前面的分组收到了。但是 SR 协议是可以乱序接收，发送的是单独的确认，并不是累积的。

### 正常情况下两种协议两个窗口的互动
- 发送窗口 
	- 有新的分组落入发送缓冲区范围，发送 -> 前沿滑动
	- 来了老的低序号分组的确认 -> 后沿向前滑动 -> 新的分组可以落入到接收窗口范围
- 接收窗口
	- 收到分组，落入到接收窗口范围内，接收
	- 是低序号，发送确认给对方


```mermaid
flowchart LR
发送端上面来了分组 --> 发送窗口滑动;
发送窗口滑动 --> 接收收窗口滑动;
接收收窗口滑动 --> 发确认;
发确认 --> 发送窗口滑动;
```

### 异常情况下 GBN 的 2 窗口互动
新分组落入发送缓冲区范围，发送 -> 前沿滑动。但是此时接收窗口却收到乱序分组，没有落入到接收窗口范围内，抛弃。接收窗口（重复）发送老分组的确认，累计确认。发送窗口来了老分组的重复确认 -> 后沿不向前滑动 -> 新的分组无法落入发送缓冲区的范围（此时如果发送缓冲区有新的分组可以发送）。经过一定时间之后，超时重发机制让发送端将**发送窗口中的所有分组**发送出去。

![|525](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250207183828.png)


### 异常情况下 SR 的 2 窗口互动
新分组落入发送缓冲区范围，发送 -> 前沿滑动。接收窗口收到乱序分组，落入到接收窗口范围内，接收，发送该分组的确认，单独确认。发送窗口来了乱序分组的确认 -> 后沿不向前滑动 -> 新的分组无法落入发送缓冲区的范围（此时如果发送缓冲区有新的分组可以发送）。超时重发机制让发送端将**超时的分组**重新发送出去。

![|525](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250207183902.png)

- 接收方对每个正确接收的分组，分别发送 ACKn（非累积确认） 
- 接收窗口 > 1。可以缓存乱序的分组，最终将分组按顺序交付给上层 
- 发送方只对那些没有收到 ACK 的分组进行重发 - 选择性重发 
- 发送方为每个未确认的分组设定一个定时器 
- 发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数

![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250207185154.png)


### 对比 GBN 和 SR
-tx-
|     |  GBN   | SR |
| --- | --- | --- | 
|  相同   |     发送窗口>1     ||
|   ^^      |      一次能够可发送多个未经确认的分组  ||
|   不同  | 接收窗口尺寸 = 1    | 接收窗口尺寸 > 1 |
| ^^ |  接收端：只能顺序接收   | 接收端：可以乱序接收 |
|^^|发送端：从表现来看，一旦一个分组没有发成功，如：0,1,2,3,4 ; 假如 1 未成功, 2 3 4 都发送出去了，要返回 1 再发送；GB1 |发送端：发送 0,1,2,3,4，一旦 1 未成功，2,3,4,已发送，无需重发，选择性发送 1|
|^^|只需设置一个定时器。当定时器到时时，重传所有未确认分组|发送方为每个未确认的分组保持一个定时器。当超时定时器到时，只是重发到时的未确认分组|
|优点|简单，所需资源少（接收方一个缓存单元）|出错时，重传一个代价小 |
|缺点|一旦出错，回退 N 步代价大 |复杂，所需要资源多（接收方多个缓存单元）|
|适用范围|出错率低：比较适合 GBN，出错非常罕见，没有必要用复杂的 SR，为罕见的事件做日常的准备和复杂处理|链路容量大（延迟大、带宽大）：比较适合 SR 而不是 GBN，一点出错代价太大|
|窗口的最大尺寸 | $2^n-1$ | $2^{n-1}$|

## 面向连接的传输 TCP
- 点对点：一个发送方，一个接收方 
- 可靠的、按顺序的字节流：没有报文边界 
- 管道化(流水线)：TCP 拥塞控制和流量控制设置窗口大小 
- 发送和接收缓存
- 全双工数据：
	- 在同一连接中数据流双向流动 
	- MSS：最大报文段大小
- 面向连接：在数据交换之前，通过握手（交换控制报文）初始化发送方、接收方的状态变量 
- 有流量控制：发送方不会淹没接收方

![|600](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250209211553899.png)

### TCP 报文结构
![|575](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250209211628204.png)

### TCP 序号, 确认号
- 序号：报文段首字节的在字节流的编号
- 确认号: 期望从另一方收到的下一个字节的序号。累积确认。
- TCP 对于接收方如何处理乱序的报文段没有规定，可以抛弃也可以缓存。

TCP 中 ACK 79 代表 78 以及之前的都已经收到，希望从 79 号开始发。

![|325](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250209211813303.png)

### TCP 往返延时（ RTT ）和超时
#### 怎样设置 TCP 超时 ？
比 RTT 要长，但是 RTT 是变化的。太短的话会太早超时，造成不必要的重传；太长的话对报文段丢失反应太慢，消极。
#### 怎样估计 RTT ？
SampleRTT：测量从报文段发出到收到确认的时间，如果有重传，忽略此次测量。
SampleRTT 会变化，因此估计的 RTT 应该比较平滑。对几个最近的测量值求平均，而不是仅用当前的 SampleRTT。

EstimatedRTT
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250209213752635.png)

![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250209213814963.png)

### TCP 可靠数据传输
TCP 在 IP 不可靠服务的基础上建立了 rdt (可靠数据传输) 
- 管道化的报文段: GBN or SR 
- 累积确认（像 GBN） 
- 单个重传定时器（像 GBN）。超时了并不会把发出去的所有段重新发一遍，而是重发最老的那一段。
- 是否可以接受乱序的，没有规范 
<br>
- 通过以下事件触发重传:
	- 超时（只重发那个最早的未确认段：SR） 
	- 重复的确认: 例如收到了ACK50, 之后又收到 3 个 ACK50 -> 快速重传

<br>

- 首先考虑简化的 TCP 发送方： 
	- 忽略重复的确认 
	- 忽略流量控制和拥塞控制

### TCP 发送方事件
![|575](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250209215351941.png)

### TCP 重传
![|600](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250209220143416.png)

![|400](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250209220506779.png)

### 产生 TCP ACK 的建议

| 接收方的事件                           | TCP 接收方动作                                                      |
| -------------------------------- | -------------------------------------------------------------- |
| 所期望序号的报文段按序到达。所有在期望序号之前的数据都已经被确认 | 延迟的 ACK。对另一个按序报文段的到达最多等待 500ms。如果下一个报文段在这个时间间隔内没有到达，则发送一个 ACK。 |
| 有期望序号的报文段到达。另一个按序报文段等待发送 ACK     | 立即发送单个累积 ACK，以确认两个按序报文段。                                       |
| 比期望序号大的报文段乱序到达。检测出数据流中的间隔        | 立即发送重复的 ACK，指明下一个期待字节 的序号                                      |
| 能部分或完全填充接收数据间隔的报文段到达。            | 若该报文段起始于间隔（gap）的低端，则立即发送 ACK。                                  |


### TCP 快速重传
![|300](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250209222605448.png)
由于超时周期往往太长，在重传丢失报文段之前的延时太长。可以通过重复的 ACK 来检测报文段丢失。发送方通常连续发送大量报文段，如果报文段丢失，通常会引起多个重复的 ACK。
![|525](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250209222709694.png)

如果发送方收到同一数据的 3 个冗余 ACK(前面还有一个正常的该数据的 ACK)，重传最小序号的段。

### TCP 流量控制
流量控制：接收方控制发送方，不让发送方发送的太多、太快以至于让接收方的缓冲区溢出。

![|650](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250209223749535.png)

### TCP 连接管理
#### 连接建立
- 在正式交换数据之前，发送方和接收方握手建立通信关系 
	- 同意建立连接（每一方都知道对方愿意建立连接） 
	- 同意连接参数

三次握手
![|650](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250209224629045.png)
第三次握手一般和数据传递一起。

TCP 传输这个初始序号不是固定的，是随机的。可以有效避免老的连接对新的连接的数据传输造成干扰。

![|625](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250209225644010.png)

#### 关闭连接
- 客户端，服务器分别关闭它自己这一侧的连接。发送 FIN bit = 1的 TCP 段 
- 一旦接收到 FIN，用 ACK 回应。接到 FIN 段，ACK 可以和它自己发出的 FIN 段一起发送
- 可以处理同时的 FIN 交换

![|625](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250209230038223.png)

### TCP 拥塞控制
#### 拥塞控制
- 拥塞的表现: 
	- 分组丢失(路由器缓冲区溢出) 
	- 分组经历比较长的延迟(在路由器的队列中排队)

![|600](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250210150305665.png)

#### TCP 拥塞控制
- 端到端的拥塞控制机制 
	- 路由器不向主机有关拥塞的反馈信息 
		- 路由器的负担较轻 
		- 符合网络核心简单的 TCP/IP 架构原则
	- 端系统根据自身得到的信息，判断是否发生拥塞，从而采取动作
- 拥塞感知
	- 某个段超时了（丢失事件）
		- 原因 1：网络拥塞（某个路由器缓冲区没空间了，被丢弃）概率大
		- 原因 2：出错被丢弃了（各级错误，没有通过校验，被丢弃）概率小
		- 一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对的
	- 有关某个段的 3 次重复 ACK：轻微拥塞
		- 网络这时还能够进行一定程度的传输，拥塞但情况要比第一种好
- 速率控制方法
	- 维持一个拥塞窗口的值：CongWin
	- 发送端限制已发送但是未确认的数据量（的上限），从而粗略地控制发送方的往网络中注入的速率。

![|600](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250210164940348.png)

- 拥塞控制和流量控制的联合动作
	- 发送端控制发送但是未确认的量同时也不能够超过接收窗口，满足流量控制要求
	- $SendWin=min\{CongWin, RecvWin\}$ 
	- 同时满足拥塞控制和流量控制要求

CA 阶段 -> 拥塞避免阶段。SS 阶段 -> 慢启动阶段。

- 拥塞控制策略:
	- 慢启动
	- AIMD：线性增、乘性减少
	- 超时事件后的保守策略

##### TCP 慢启动
- 连接刚建立, CongWin = 1 MSS
- 当连接开始时，指数性增加发送速率，直到发生丢失的事件。
- 启动初值很低，但是速度很快

![|575](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250210170309796.png)

##### AIMD
![|575](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250210170414204.png)

- 当收到 3 个重复的 ACKs: 
	- CongWin减半 
	- 窗口（缓冲区大小）之后线性增长 
- 当超时事件发生时: 
	- CongWin 被设置成 1 MSS，进入 SS 阶段 
	- 之后窗口指数增长。增长到一个阈值（上次发生拥塞的窗口的一半）时 ，再线性增加

![|600](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250210184618343.png)

#### TCP 发送端拥塞控制

![|600](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250210184650995.png)

