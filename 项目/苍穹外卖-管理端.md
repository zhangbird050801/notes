---
tags:
  - JavaWeb
  - 项目
---

用户端见[[苍穹外卖-用户端]]

## 项目结构

| 名称     | 说明                                  |
| ------ | ----------------------------------- |
| Entity | 实体，与数据库中的表对应                        |
| DTO    | 数据传输对象，通常用于程序中各层之间传递数据              |
| VO     | 视图对象，为前端展示数据提供的对象                   |
| POJO   | 普通 Java 对象，只有属性和对应的 getter 和 setter |

前后端联调
![|950](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217121652581.png)

项目大致结构
![|175](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217124105567.png)

异常放在 sky-common 下的 exception 包中
![|400](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217131958971.png)

而在 sky-server 的 handler 包下配置了全局异常处理器。
![|925](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217132046903.png)

`application-dev.yml` 文件配置数据库用户名和密码。
![|1050](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217124219778.png)

前端 nginx 启动，端口在 80。后端启动，端口在 8080。

访问 `localhost` 会跳转到 `http://localhost/#/login`
![|675](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217124453391.png)

管理员账号密码存储在数据库 `employee` 表下。此时存储在数据库中的密码并没有加密。
![|825](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217124603747.png)

## 登录
![|725](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217130623847.png)

![|900](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217130726161.png)

之后步过这一步，进入 login 方法打个断点。
![|775](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217130955250.png)

可以看到前端发送的请求为：
![|600](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217130901073.png)

login 的具体实现:
![|1000](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217131104263.png)
这里面是用到了 mapper 调查数据库中的对象。
![|900](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217131403468.png)
简单的数据库语句使用注解的方式，复杂的 sql 用 xml。
```java
@Select("select * from employee where username = #{username}")
```

mapper 层查找到这个用户返回给 service 层，然后再比对用户密码、判断账户是否被锁定，核验成功后 service 层再把对象返回给 controller 层。
![|1050](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217131214421.png)

生成 jwt 令牌，参数通过 `jwtProperties` 传入。
![|925](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217132457328.png)

`jwtProperties` 中的属性在配置文件中可以找到。
![|925](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217132710945.png)

最后数据封装成 VO 对象，放在 Result 里面响应给前端页面。
![|875](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217132858819.png)

`EmployeeLoginVO` 包括 id、用户名、姓名、jwt 令牌。 这里构造对象用的 `builder()` 方法，使用这个方法必须要在 VO 对象上加入注解 `@Builder`
![|500](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217132958874.png)

## 前后端如何交互
从刚才登录的例子可以看到，前端发送的请求地址 `/api/employee/login`。但是后端 Controller 中定义的请求地址是 `/admin/employee/login`。与此同时，前端是 `localhost` 或者 `localhost:80`，但是后端是 `localhost:8080`。那么前端发送的请求到底是如何传给后端的呢？
```java
@RequestMapping("/admin/employee")
```

=> 通过 nginx 反向代理
![|800](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217134125060.png)
![|800](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217134322303.png)
使用 nginx 反向代理，可以保证提高访问速度、进行负载均衡(把大量的请求按照我们指定的方式均衡的分配给集群中的每台服务器)、保证后端服务的安全。

在 nginx 的配置文件中可以配置反向代理：
![|575](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217134849548.png)

```conf
server {
	listen       80;
	server_name  localhost;

	# 反向代理,处理管理端发送的请求
	location /api/ {
		proxy_pass   http://localhost:8080/admin/;
		#proxy_pass   http://webservers/admin/;
	}
}
```

![|900](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217135027834.png)

## 完善登录功能
由于前面看到，密码存储在数据库中是以明文的方式，安全系数低。我们可以用 MD5 加密，让存储在数据库中的密码是加密后的密码，但是有一个问题就是，前端用户输入还是原来明文的密码，所以我们在登录检验的过程中要把用户输入的密码转换成 MD5 加密后的密码，然后再和数据库中的密码进行比对。
不过，原先存储在数据库中的用户密码我们需要改成 MD5 加密，这里手动修改一下就行。
![|575](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217145350460.png)

将 `EmployeeServiceImpl.java` 中的这段代码
```java
// TODO 后期需要进行md5加密，然后再进行比对  
if (!password.equals(employee.getPassword())) {  
    //密码错误  
    throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR);  
}  
  
if (employee.getStatus() == StatusConstant.DISABLE) {  
    //账号被锁定  
    throw new AccountLockedException(MessageConstant.ACCOUNT_LOCKED);  
}
```
改为
```java
password = DigestUtils.md5DigestAsHex(password.getBytes());  
if (!password.equals(employee.getPassword())) {  
    //密码错误  
    throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR);  
}  
  
if (employee.getStatus() == StatusConstant.DISABLE) {  
    //账号被锁定  
    throw new AccountLockedException(MessageConstant.ACCOUNT_LOCKED);  
}
```

## 接口
使用 apifox 导入，选择数据格式为 `YApi`
![|850](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217154903580.png)

![|850](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217155051341.png)

最后导入完两个项目大概是这样：
![|1175](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217155228468.png)

- 本项目规定
	- 管理端发出的请求，统一使用 `/admin` 作为前缀
	- 用户端发出的请求，统一使用 `/user` 作为前缀
### Swagger
用 Swagger 帮助后端生成接口文档，并且可以进行后端的接口测试。导入 knife4j 来使用，不过项目里已经为我们导入好了
```xml
<dependency>  
    <groupId>com.github.xiaoymin</groupId>  
    <artifactId>knife4j-spring-boot-starter</artifactId>  
    <version>3.0.2</version>  
</dependency>
```

配置文件位于 `sky-take-out/sky-server/src/main/java/com/sky/config/WebMvcConfiguration.java`
```java
@Configuration  
@Slf4j  
public class WebMvcConfiguration extends WebMvcConfigurationSupport {  
  
    @Autowired  
    private JwtTokenAdminInterceptor jwtTokenAdminInterceptor;  
  
    /**  
     * 注册自定义拦截器  
     *  
     * @param registry  
     */  
    protected void addInterceptors(InterceptorRegistry registry) {  
        log.info("开始注册自定义拦截器...");  
        registry.addInterceptor(jwtTokenAdminInterceptor)  
                .addPathPatterns("/admin/**")  
                .excludePathPatterns("/admin/employee/login");  
    }  
  
    /**  
     * 通过knife4j生成接口文档  
     * @return  
     */  
    @Bean  
    public Docket docket() {  
        ApiInfo apiInfo = new ApiInfoBuilder()  
                .title("苍穹外卖项目接口文档")  
                .version("2.0")  
                .description("苍穹外卖项目接口文档")  
                .build();  
        Docket docket = new Docket(DocumentationType.SWAGGER_2)  
                .apiInfo(apiInfo)  
                .select()  
                .apis(RequestHandlerSelectors.basePackage("com.sky.controller"))  
                .paths(PathSelectors.any())  
                .build();  
        return docket;  
    }  
  
    /**  
     * 设置静态资源映射  
     * @param registry  
     */  
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {  
        registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");  
        registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");  
    }  
}
```

其中，这句话指定了扫描的包：
```java
.apis(RequestHandlerSelectors.basePackage("com.sky.controller"))  
```

{% link 接口文档, swagger , http://localhost:8080/doc.html#/home %}

![|950](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217160312254.png)

如果配置的时候没有写静态资源映射，SpringMVC 会认为请求的不是静态资源，而是一个动态请求，会请求某个 controller，所以访问界面会报 404。

Swagger 常用注解:

|                   |                            |
| ----------------- | -------------------------- |
| @Api              | 用在类上，例如 Controller，表示对类的说明 |
| @ApiModel         | 用在类上，例如 entity、DTO、VO      |
| @ApiModelProperty | 用在属性上，描述属性信息               |
| @ApiOperation     | 用在方法上，说明方法的用途、作用           |

```java
@Api(tags = "员工相关接口")  
public class EmployeeController {
}
```

```java
@ApiOperation(value = "员工登录")  // 也可以省略 value
public Result<EmployeeLoginVO> login(@RequestBody EmployeeLoginDTO employeeLoginDTO) {
}
```

之后重新启动项目进入文档，可以看到这边名字都变成刚才指定的了。
![|325](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217164935857.png)

## 员工模块
### 新增员工
#### 需求分析
![|625](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217172526210.png)
#### 数据表分析
对于 `employee` 表:
![|750](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217172431504.png)

可以看到 `username` 是唯一的，然后 `id` 是自增的。
![|350](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217172700183.png)

#### DTO 设计
当前端提交的数据和实体类中对应的属性差别较大的时候，建议用 DTO 来封装数据。
![|675](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217182333234.png)

`sky-take-out/sky-pojo/src/main/java/com/sky/dto/EmployeeDTO.java`
```java
@Data  
public class EmployeeDTO implements Serializable {  
  
    private Long id;  
  
    private String username;  
  
    private String name;  
  
    private String phone;  
  
    private String sex;  
  
    private String idNumber;  
  
}
```
#### Controller 层
提交过来的数据是 `json` 格式的，需要在参数前面加上 `@RequestBody` 
```java
@PostMapping  
@ApiOperation("新增员工")  
public Result save(@RequestBody EmployeeDTO employeeDTO) {  
    log.info("新增员工，员工信息：{}", employeeDTO);  
    employeeService.save(employeeDTO);  
    return Result.success();  
}
```
#### Service 层
传过来的是一个 DTO 对象，但是由于这个 DTO 中只有部分属性，后续用到还可能有别的属性，存到数据库中还是用原来的 Employee 比较好。通过对象属性拷贝，可以将 DTO 对象中的属性复制到实体类的对应属性。其余的一些属性需要我们手动设置，不过这里留个坑先，先固定写死创建用户和修改用户，后期进行完善。
```java
@Override  
public void save(EmployeeDTO employeeDTO) {  
    Employee employee = new Employee();  
  
    // 属性拷贝  
    BeanUtils.copyProperties(employeeDTO, employee);  
  
    // 设置账户属性，ENABLE 为启用  
    employee.setStatus(StatusConstant.ENABLE);  
  
    // 设置密码，默认为 123456(存储在 PasswordConstant 里的 DEFAULT_PASSWORD)，同时用 MD5 进行加密  
    employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));  
  
    // 设置创建时间和修改时间  
    employee.setCreateTime(LocalDateTime.now());  
    employee.setUpdateTime(LocalDateTime.now());  
  
    // 设置创建人 ID 和修改人 ID    
    // TODO: 后期需要改为当前登录用户的 ID    
    employee.setCreateUser(10L);  
    employee.setUpdateUser(10L);  
  
    // 调用 mapper    
    employeeMapper.insert(employee);  
}
```
#### Mapper 层
由于在项目配置文件中开启了驼峰命名，属性中，比如 createTime 可以转换为 create_time
![|575](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250217185801142.png)

```java
@Insert("insert into employee (name, username, password, phone, sex, id_number, status, create_time, update_time, create_user, update_user) " +  
        "values " +  
        "(#{name}, #{username}, #{password}, #{phone}, #{sex}, #{idNumber}, #{status}, #{createTime}, #{updateTime}, #{createUser}, #{updateUser})")  
void insert(Employee employee);
```
#### 存在的问题
- 由于数据库中字段 username 设置为了 unique。但是录入的用户名已经存在，抛出异常后没有处理
	- 响应码为 500
	- ![](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250218114659048.png)
	- 后端控制台 `java.sql.SQLIntegrityConstraintViolationException` 异常
	- ![|625](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250218114742236.png)
- 新增员工时，创建人 id 和修改人 id 设置为了固定值
#### 代码完善
##### 异常处理
可以使用全局的异常处理器对 `SQLIntegrityConstraintViolationException` 异常进行捕获并处理。异常信息提示 `Duplicate entry '鸟王' for key 'employee.idx_username'`, 所以我们可以判断获得的信息中有没有 `Duplicate entry` 这个关键字，如果有的话，就是这种重复用户名的异常。这里如果我们想提示用户，"鸟王已存在"，那么我们可以将这个错误消息提示根据空格进行分割成数组，这个重复的用户名就是下标为 2。然后其他的异常就抛出 "未知错误"。

可以在信息提示常量类 MessageConstant 中添加：
```java
public static final String ALREADY_EXISTS = "已存在";
```

在全局异常处理器 GlobalExceptionHandler 中添加：
```java
@ExceptionHandler  
public Result exceptionHandler(SQLIntegrityConstraintViolationException ex) {  
    String message = ex.getMessage();  
    if(message.contains("Duplicate entry")) {  
        String[] split = message.split(" ");  
        String msg = split[2] + MessageConstant.ALREADY_EXISTS;  
        return Result.error(msg);  
    }  
  
    return Result.error(MessageConstant.UNKNOWN_ERROR);  
}
```

重新运行项目再新增同样的员工，就可以看到这个提示信息了。
![|900](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250218115853752.png)

##### 动态获取 id
前面在设置创建人和修改人 ID 的时候，我们用了固定值。显然是不合理的，那么该如何动态获取当前登录用户的 ID 呢？
```java
// 设置创建人 ID 和修改人 ID    
// TODO: 后期需要改为当前登录用户的 ID    
employee.setCreateUser(10L);  
employee.setUpdateUser(10L);  
```

首先，我们的流程是：
![|575](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250218120253565.png)

认证通过生成 JWT Token 的时候，已经把我们的 id 放进去了。
`EmployeeController.java`
```java
//登录成功后，生成jwt令牌  
Map<String, Object> claims = new HashMap<>();  
claims.put(JwtClaimsConstant.EMP_ID, employee.getId());  
String token = JwtUtil.createJWT(  
        jwtProperties.getAdminSecretKey(),  
        jwtProperties.getAdminTtl(),  
        claims);
```
所以我们获取 JWT Token 的时候，就可以解析出这个用户的 id。
在 `JwtTokenAdminInterceptor.java` 种
```java
//1、从请求头中获取令牌  
String token = request.getHeader(jwtProperties.getAdminTokenName());  
  
//2、校验令牌  
try {  
    log.info("jwt校验:{}", token);  
    Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);  
    Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());  
    log.info("当前员工id：", empId);  
    //3、通过，放行  
    return true;
}
```

获取了用户 id：
```java
Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());  
```

但是解析出登录员工 id 之后，如何传递给 Service 的 save 方法呢？
=> 可以用到 ThreadLocal
```ad-info
ThreadLocal 并不是一个 Thread，而是 Thread 的局部变量。 
ThreadLocal 为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。
```

同时: 
```ad-warning
客户端发送的每次请求，后端的 Tomcat 服务器都会分配一个单独的线程来处理请求
```

ThreadLocal 常用方法:
```java
public void set(T value)  // 设置当前线程的线程局部变量的值
public T get()            // 返回当前线程所对应的线程局部变量的值
public void remove()      // 移除当前线程的线程局部变量
```

也就是说，在这一个线程的整个生命周期之内，我们可以共享这个存储空间里面的内容。所以我们在拦截器那里可以把当前用户 id 存储到这个线程存储空间里面去，当执行到 service 的 save 方法，再把用户 id 从存储空间内取出来。

在 `sky-take-out/sky-common/src/main/java/com/sky/context/BaseContext.java` 已经提供了这些方法
```java
public class BaseContext {  
  
    public static ThreadLocal<Long> threadLocal = new ThreadLocal<>();  
  
    public static void setCurrentId(Long id) {  
        threadLocal.set(id);  
    }  
  
    public static Long getCurrentId() {  
        return threadLocal.get();  
    }  
  
    public static void removeCurrentId() {  
        threadLocal.remove();  
    }  
  
}
```

在拦截器 JwtTokenAdminInterceptor 中，从请求头获取 id 之后，存入到线程存储空间中。
```java
//2、校验令牌  
try {  
    log.info("jwt校验:{}", token);  
    Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);  
    Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());  
    log.info("当前员工id：", empId);  
  
    BaseContext.setCurrentId(empId);   // 加入这一行
    //3、通过，放行  
    return true;  
}
```

在 EmployeeServiceImpl 中，之前的代码改为
```java
// 设置创建人 ID 和修改人 ID 为 当前登录用户的 ID
employee.setCreateUser(BaseContext.getCurrentId());  
employee.setUpdateUser(BaseContext.getCurrentId());
```
### 员工分页查询
#### 需求分析
![|550](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250218135705112.png)

#### DTO 设计
EmployeePageQueryDTO:
```java
@Data  
public class EmployeePageQueryDTO implements Serializable {  
  
    //员工姓名  
    private String name;  
  
    //页码  
    private int page;  
  
    //每页显示记录数  
    private int pageSize;  
  
}
```

对于分页查询的结果，统一封装成 PageResult 对象。最后返回给前端就是 `Result<PageResult>`
```java
@Data  
@AllArgsConstructor  
@NoArgsConstructor  
public class PageResult implements Serializable {  
  
    private long total; //总记录数  
  
    private List records; //当前页数据集合  
  
}
```

#### Controller 层
请求的时候传入的数据格式不是 json，所以不需要加入 `@RequestBody` 注解。
```java
@GetMapping("/page")  
@ApiOperation("员工分页查询")  
public Result<PageResult> page(EmployeePageQueryDTO employeePageQueryDTO) {  
    PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);  
    return Result.success(pageResult);  
}
```

#### Service 层
由于分页查询实际上是基于底层数据库，如果我们想从第一页开始查询十条记录，那么 SQL 语句就是：
```sql
select * from employee limit 0, 10
```

不过，mybatis 提供了 pageHelper 插件，可以动态帮我们拼接 limit 以及页码和条数，我们已经导入了这个插件
```xml
<dependency>  
    <groupId>com.github.pagehelper</groupId>  
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>${pagehelper}</version>  
</dependency>
```

从 Mapper 层返回的是一个 `Page<Employee>` 对象，但是我们 Service 要返回的是 `PageResult` 对象，所以还需要处理一下。
```java
@Override  
public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) {  
    // 开始分页查询  
    PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());  
  
    Page<Employee> page = employeeMapper.pageQuery(employeePageQueryDTO);  
  
    long total = page.getTotal();  
    List<Employee> records = page.getResult();  
  
    return new PageResult(total, records);  
}
```
#### Mapper 层
```java
/**  
 * 分页查询员工  
 * @param employeePageQueryDTO  
 * @return  
 */  
Page<Employee> pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
```

这里不适合用注解方式，我们使用动态 SQL 编写，映射文件在 `sky-take-out/sky-server/src/main/resources/mapper/EmployeeMapper.xml`。同时，配置文件中已经指定了扫描路径。
```yml
mybatis:  
  # mapper配置文件  
  mapper-locations: classpath:mapper/*.xml
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >  
<mapper namespace="com.sky.mapper.EmployeeMapper">  
</mapper>
```

查询的时候我们用模糊查询，用 `concat` 进行拼接。最后结果按创建时间进行降序排序。
```xml
<select id="pageQuery" resultType="com.sky.entity.Employee">  
    select * from employee  
    <where>  
        <if test="name != null and name != ''">  
            and name like concat('%', #{name}, '%')
        </if>  
    </where>  
    order by create_time desc  
</select>
```

#### 存在的问题
相应回来的日期格式是这样的。
![|775](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250218150348953.png)

![|425](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250218150412579.png)

我们想要把它改成年月日 时分那种形式，这样直观点。
#### 代码完善
- 有两种解决方式
	- 在属性上加上注解，对日期进行格式化
		- ![|500](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250218152021920.png)
		- 但是这种方式比较麻烦，后期遇到事件还要一个个手动添加。
	- 在 `WebMvcConfiguration` 中扩展 `SpringMVC` 的消息转换器，统一对日期类型进行格式化处理，

WebMvcConfiguration 中添加：
```java
/**  
 * 扩展 SpringMVC 框架的消息转换器  
 * @param converters  
 */  
@Override  
protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {  
    // 创建一个消息转换器对象  
    MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();  
  
    // 为消息转换器设置一个对象转换器，将 Java 对象转为 json 数据  
    converter.setObjectMapper(new JacksonObjectMapper());  
  
    // 将上面的消息转换器对象追加到 SpringMVC 框架的转换器集合中  
    // 并且设置优先使用  
    converters.add(0, converter);  
}
```

可以看到现在显示的时间是正常的。
![|252](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250218164120380.png)

### 启用禁用员工账号
#### 需求分析
- 可以对状态为 “启用” 的员工账号进行 “禁用” 操作 
- 可以对状态为 “禁用” 的员工账号进行 “启用” 操作 
- 状态为 “禁用” 的员工账号不能登录系统
![|600](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250218164410355.png)

#### Controller 层
对于非查询类的，返回结果只用 code，data 往往是空的，所以可以不用泛型，直接返回 `Result`。传过来的参数有 status 和 id，由于 status 是路径参数，需要加上注解 `@PathVariable`。而 id 是地址栏传过来的，所以只需要参数名对应就行。
```java
@PostMapping("/status/{status}")  
@ApiOperation("启用禁用员工账号")  
public Result startOrStop(@PathVariable Integer status, Long id) {  
    employeeService.startOrStop(status, id);  
    return Result.success();  
}
```

#### Service 层
最终我们希望传过去的 sql 语句是
```sql
update employee set status = ? where id = ?
```

不过，我们希望这个 update 语句可以更通用些，比如传入别的参数的话就修改别的参数，所以写成动态的 SQL 更好。

所以我们这里调用 mapper 层的时候，就不应该只传入 status 和 id, 我们应该传入一个 Employee 对象。
```java
@Override  
public void startOrStop(Integer status, Long id) {  
    Employee employee = Employee.builder()  
                                .status(status)  
                                .id(id)
                                .updateTime(LocalDateTime.now())  
                                .updateUser(BaseContext.getCurrentId())  
                                .build();  
  
    employeeMapper.update(employee);  
}
```
#### Mapper 层
```java
/**  
 * 根据 id 修改员工属性  
 * @param employee  
 */  
void update(Employee employee);
```

由于是动态 SQL，我们在对应的 EmployeeMapper.xml 中编写。
```java
<update id="update" parameterType="Employee">  
    update employee  
    <set>  
        <if test="name != null">name = #{name},</if>  
		<if test="username != null">username = #{username},</if>  
		<if test="password != null">password = #{password},</if>  
		<if test="phone != null">phone = #{phone},</if>  
		<if test="sex != null">sex = #{sex},</if>  
		<if test="idNumber != null">id_Number = #{idNumber},</if>  
		<if test="updateTime != null">update_Time = #{updateTime},</if>  
		<if test="updateUser != null">update_User = #{updateUser},</if>  
		<if test="status != null">status = #{status},</if>
    </set>  
    where id = #{id}  
</update>
```

这里 `parameterType="Employee"` 可以不写全包名，因为在配置文件中 `type-aliases-package: com.sky.entity` 自动扫描指定包路径下的类，并为这些类创建别名。
```yml
mybatis:  
  type-aliases-package: com.sky.entity
```

### 编辑员工
#### 需求分析
设计到两个接口
- 根据 id 查询员工信息 -> 在修改页面进行回显
	- ![|675](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250218172701465.png)
- 编辑员工信息
	- ![|675](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250218172726082.png)
#### Controller 层
根据 id 返回员工信息，这个 id 我们可以从接口路径中看出来是一个路径参数，需要用到 `@PathVariable`。
```java
@GetMapping("/{id}")  
@ApiOperation("根据 id 查询员工信息")  
public Result<Employee> getById(@PathVariable Long id) {  
    Employee employee = employeeService.getById(id);  
    return Result.success(employee);  
}
```

编辑员工这里传入的参数是 json 格式，需要用 `@RequestBody`
```java
@PutMapping  
@ApiOperation("编辑员工信息")  
public Result update(@RequestBody EmployeeDTO employeeDTO) {  
    employeeService.update(employeeDTO);  
    return Result.success();  
}
```

#### Service 层
为了加强安全性，将传给前端的密码 "手动加密"。
```java
@Override  
public Employee getById(Long id) {  
    Employee employee = employeeMapper.getById(id);  
    employee.setPassword("****");  
    return employee;  
}
```

之前我们已经在 mapper 层定义了 update 方法，不过当时接收的是 `Employee` 对象，而现在传递过来的是 `EmployeeDTO` 对象，所以我们可以通过对象拷贝，将属性复制过去。同时，修改信息的时候还要更新修改时间和修改用户。
```java
@Override  
public void update(EmployeeDTO employeeDTO) {  
    Employee employee = new Employee();  
    BeanUtils.copyProperties(employeeDTO, employee);  
  
    employee.setUpdateTime(LocalDateTime.now());  
    employee.setUpdateUser(BaseContext.getCurrentId());  
  
    employeeMapper.update(employee);  
}
```
#### Mapper 层
```java
@Select("select * from employee where id = #{id}")  
Employee getById(Long id);
```

#### // TODO: 发现 BUG
```ad-failure
-> 测试的时候发现一个 bug。之前新增员工注册的账号，我用的中文名可以新增成功，但在这里就会报错。
```

![|750](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250218184049631.png)

### 修改密码
#### 需求分析
![|425](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250219113857577.png)

可以看到传过来的为 json 数据，所以到时候要加上 `@RequestBody`
![|700](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250219113829839.png)
#### DTO 设计
使用 `PasswordEditDTO`
![|700](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250219115141020.png)

```java
@Data  
public class PasswordEditDTO implements Serializable {  
  
    //员工id  
    private Long empId;  
  
    //旧密码  
    private String oldPassword;  
  
    //新密码  
    private String newPassword;  
  
}
```

然而有一个 bug，就是前端并没有传递 empId。这边默认是本人修改密码，所以我就打算直接用 `BaseContext` 获取用户 id 了。

#### Controller 层

```java
@PutMapping("/editPassword")  
@ApiOperation("修改密码")  
public Result editPassword(@RequestBody PasswordEditDTO passwordEditDTO) {  
    employeeService.editPassword(passwordEditDTO);  
    return Result.success();  
}
```

#### Service 层
```java
@Override  
public void editPassword(PasswordEditDTO passwordEditDTO) {  
    String oldPassword = passwordEditDTO.getOldPassword();  
    String newPassword = passwordEditDTO.getNewPassword();  
    Long empId = BaseContext.getCurrentId();  
  
    Employee employee = employeeMapper.getById(empId);  
  
    oldPassword = DigestUtils.md5DigestAsHex(oldPassword.getBytes());  
    newPassword = DigestUtils.md5DigestAsHex(newPassword.getBytes());  
  
    if(oldPassword.equals(employee.getPassword())) {  
        employee.setPassword(newPassword);  
  
        employee.setUpdateTime(LocalDateTime.now());  
        employee.setUpdateUser(empId);  
  
        employeeMapper.update(employee);  
    } else {  
        throw new PasswordErrorException(PASSWORD_ERROR);  
    }  
}
```

Mapper 层就是调用之前写好的 update，所以这里不用再写了。

## 分类模块
- 分类名称必须是唯一的
- 分类按照类型可以分为菜品分类和套餐分类
- 新添加的分类状态默认为 "禁用"

### 文件准备
- mapper:
	- CategoryMapper
	- DishMapper
	- SetmealMapper
- mapper 映射文件
	- CategoryMapper.xml
- Service
	- CategoryService
	- Impl
		- CategoryServiceImpl
- Controller
	- CategoryController

`com.sky.controller.admin.CategoryController`
```java
@RestController  
@RequestMapping("/admin/category")  
@Api(tags = "分类管理")  
@Slf4j  
public class CategoryController {  
    @Autowired  
    private CategoryService categoryService;  
  
}
```

`com.sky.service.impl.CategoryServiceImpl`
```java
@Service  
public class CategoryServiceImpl implements CategoryService {  
    @Autowired  
    private CategoryMapper categoryMapper;  
  
    @Autowired  
    private SetmealMapper setmealMapper;  
  
    @Autowired  
    private DishMapper dishMapper;  
}
```

`com.sky.service.CategoryService`
```java
public interface CategoryService {  
}
```

`com.sky.mapper.CategoryMapper`
```java
@Mapper  
public interface CategoryMapper {  
}
```

`com.sky.mapper.DishMapper
```java
@Mapper  
public interface DishMapper {  
}
```

`com.sky.mapper.SetmealMapper`
```java
@Mapper  
public interface SetmealMapper {  
}
```

`sky-take-out/sky-server/src/main/resources/mapper/CategoryMapper.xml`
```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >  
<mapper namespace="com.sky.mapper.CategoryMapper">  
  
</mapper>
```

### 新增分类
#### 需求分析
传过来的参数为 json 格式，要加上 `@RequestBody`
![|700](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250219135419595.png)

#### 数据表分析
Category: 
![|725](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250219140052223.png)

```java
@Data  
@Builder  
@NoArgsConstructor  
@AllArgsConstructor  
public class Category implements Serializable {  
  
    private static final long serialVersionUID = 1L;  
  
    private Long id;  
  
    //类型: 1菜品分类 2套餐分类  
    private Integer type;  
  
    //分类名称  
    private String name;  
  
    //顺序  
    private Integer sort;  
  
    //分类状态 0标识禁用 1表示启用  
    private Integer status;  
  
    //创建时间  
    private LocalDateTime createTime;  
  
    //更新时间  
    private LocalDateTime updateTime;  
  
    //创建人  
    private Long createUser;  
  
    //修改人  
    private Long updateUser;  
}
```


#### DTO 设计
传过来的参数和 `CategoryDTO` 对应
```java
@Data  
public class CategoryDTO implements Serializable {  
  
    //主键  
    private Long id;  
  
    //类型 1 菜品分类 2 套餐分类  
    private Integer type;  
  
    //分类名称  
    private String name;  
  
    //排序  
    private Integer sort;  
  
}
```

#### Controller 层
```java
@PostMapping  
@ApiOperation("新增分类")  
public Result save(@RequestBody CategoryDTO categoryDTO) {  
    categoryService.save(categoryDTO);  
    return Result.success();  
}
```

#### Service 层
因为新增到数据库中，还需要添加很多数据，传过去的是 `Category` 对象，而不是 `CategoryDTO`，所以我们还需要调整一下。然后还要更新创建时间、修改时间、创建用户、修改用户。

```ad-warning
注意这里要让新添加的分类为禁用状态。
```

在 StatusConstant 中定义了状态常量
```java
/**  
 * 状态常量，启用或者禁用  
 */  
public class StatusConstant {  
  
    //启用  
    public static final Integer ENABLE = 1;  
  
    //禁用  
    public static final Integer DISABLE = 0;  
}
```

最终我们的代码为
```java
@Override  
public void save(CategoryDTO categoryDTO) {  
    Category category = new Category();  
    BeanUtils.copyProperties(categoryDTO, category);  
  
    category.setCreateTime(LocalDateTime.now());  
    category.setUpdateTime(LocalDateTime.now());  
    category.setCreateUser(BaseContext.getCurrentId());  
    category.setUpdateUser(BaseContext.getCurrentId());  
  
    // 默认为禁用  
    category.setStatus(StatusConstant.DISABLE);  
  
    categoryMapper.save(category);  
}
```

#### Mapper 层
简单的 sql 语句我们直接用注解就行了。
```java
@Insert("insert into category (type, name, sort, status, create_time, update_time, create_user, update_user) " +  
        "values " +  
        "(#{type}, #{name}, #{sort}, #{status}, #{createTime}, #{updateTime}, #{createUser}, #{updateUser})")  
void save(Category category);
```

#### 测试
新增一个分类，可以看到 status 默认为禁用状态。
![|725](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250219140940334.png)

### 分类分页查询
#### 需求分析
最终结果按照 `sort` 进行升序，如果 `sort` 一样则创建时间降序。
同时，可以通过 `分类名称` 和 `分类类型` 进行查询。
![|450](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250219141223388.png)

#### DTO 设计
`CategoryPageQueryDTO`
```java
@Data  
public class CategoryPageQueryDTO implements Serializable {  
  
    //页码  
    private int page;  
  
    //每页记录数  
    private int pageSize;  
  
    //分类名称  
    private String name;  
  
    //分类类型 1菜品分类  2套餐分类  
    private Integer type;  
  
}
```

#### Controller 层
```java
@GetMapping("/page")  
@ApiOperation("分类分页查询")  
public Result<PageResult> page(CategoryPageQueryDTO categoryPageQueryDTO) {  
    PageResult pageResult = categoryService.pageQuery(categoryPageQueryDTO);  
    return Result.success(pageResult);  
}
```

#### Service 层
类似于员工分页查询
```java
@Override  
public PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO) {  
    PageHelper.startPage(categoryPageQueryDTO.getPage(), categoryPageQueryDTO.getPageSize());  
  
    Page<Category> page = categoryMapper.pageQuery(categoryPageQueryDTO);  
  
    long total = page.getTotal();  
    List<Category> records = page.getResult();  
  
    return new PageResult(total, records);  
}
```

#### Mapper 层
```java
Page<Category> pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);
```

映射文件中：
```xml
<select id="pageQuery" resultType="com.sky.entity.Category">  
    select * from category  
    <where>  
        <if test='name != null and name != ""'>  
            and name like concat('%', #{name}, '%')  
        </if>  
        <if test="type != null">  
            and type = #{type}  
        </if>  
    </where>  
    order by sort asc , create_time desc  
</select>
```

#### 测试
![|725](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250219143911545.png)

### 启用禁用分类
#### 需求分析
status 是路径参数，需要用到 `@PathVariable`
![|750](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250219144509802.png)

#### Controller 层
```java
@PostMapping("/status/{status}")  
@ApiOperation("启用禁用分类")  
public Result startOrStop(@PathVariable Integer status, Long id) {  
    categoryService.startOrStop(status, id);  
  
    return Result.success();  
}
```

#### Service 层
直接用 update 方法，不止可以修改状态一个属性，后续更新方法也能用。
```java
@Override  
public void startOrStop(Integer status, Long id) {  
    Category category = Category.builder()  
                                .status(status)  
                                .id(id)  
                                .updateTime(LocalDateTime.now())  
                                .updateUser(BaseContext.getCurrentId())  
                                .build();  
    categoryMapper.update(category);  
}
```

#### Mapper 层
```java
void update(Category category);
```

在 xml 映射文件
```xml
<update id="update">  
    update category  
    <set>  
        <if test="name != null">name = #{name},</if>  
        <if test="type != null">type = #{type},</if>  
        <if test="sort != null">sort = #{sort},</if>  
        <if test="status != null">status = #{status},</if>  
        <if test="updateTime != null">update_time = #{updateTime},</if>  
        <if test="updateUser != null">update_user = #{updateUser}</if>  
    </set>  
    where id = #{id}  
</update>
```

### 修改分类
#### 需求分析
穿过的数据为 json 格式，所以要用 `@RequestBody`
![|725](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250219163850861.png)

#### Controller 层
这里使用 CategoryDTO
```java
@PutMapping  
@ApiOperation("修改分类")  
public Result update(@RequestBody CategoryDTO categoryDTO) {  
    categoryService.update(categoryDTO);  
    return Result.success();  
}
```

#### Service 层
要将 CategoryDTO 转换为 Category，并且设置更新时间和更新用户
```java
@Override  
public void update(CategoryDTO categoryDTO) {  
    Category category = new Category();  
  
    BeanUtils.copyProperties(categoryDTO, category);  
  
    category.setUpdateTime(LocalDateTime.now());  
    category.setUpdateUser(BaseContext.getCurrentId());  
  
    categoryMapper.update(category);  
}
```

Mapper 层之前已经写好了 update。

### 删除分类
#### 需求分析
![|725](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250219171145134.png)

#### Controller 层
```java
@DeleteMapping  
@ApiOperation("删除分类")  
public Result deleteById(Long id) {  
    categoryService.deleteById(id);  
    return Result.success();  
}
```

#### Service 层
要删除分类的话，如果分类底下有关联的套餐数据或者菜品数据，那就不能直接删除。我们后面会在 DishMapper 和 SetmealMapper 中编写根据分类 Id 统计数量的方法，因此可以看出来该分类有没有关联套餐数据或者菜品数据。
```java
@Override  
public void deleteById(Long id) {  
    Integer countDish = dishMapper.countByCategoryId(id);  
    Integer countSetmeal = setmealMapper.countByCategoryId(id);  
  
    if(countDish > 0) {  
        throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_DISH);  
    }  
  
    if(countSetmeal > 0) {  
        throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_SETMEAL);  
    }  
  
    categoryMapper.deleteById(id);  
}
```

#### Mapper 层
CategoryMapper
```java
@Delete("delete from category where id = #{id}")  
void deleteById(Long id);
```

DishMapper
```java
@Select("select count(id) from dish where category_id = #{categoryId}")  
Integer countByCategoryId(Long categoryId);
```

SetmealMapper
```java
@Select("select count(id) from setmeal where category_id = #{categoryId}")  
Integer countByCategoryId(Long categoryId);
```

### 根据类型查询分类
#### 需求分析
![|675](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250219171425008.png)


#### Controller 层
```java
@GetMapping("/list")  
@ApiOperation("根据类型查询分类")  
public Result<List<Category>> list(Integer type) {  
    List<Category> list = categoryService.list(type);  
    return Result.success(list);  
}
```

#### Service 层
```java
@Override  
public List<Category> list(Integer type) {  
    return categoryMapper.list(type);  
}
```

#### Mapper 层
```java
List<Category> list(Integer type);
```

xml 映射文件中
```xml
<select id="list" resultType="com.sky.entity.Category">  
    select * from category  
    <if test="type != null">  
        and type = #{type}  
    </if>  
    order by sort asc,create_time desc  
</select>
```

不过我看黑马给出来的是：(不知道为啥要加个 `where status = 1`)
```xml
<select id="list" resultType="Category">
        select * from category
        where status = 1
        <if test="type != null">
            and type = #{type}
        </if>
        order by sort asc,create_time desc
    </select>
```

```ad-warning
后续测试发现，不加 where status = 1 会报错
```

## 公共字段填充
业务表都有这些公共字段，我们每次都要重复性地进行赋值，这样会导致程序中冗余代码多，不便于后期维护。
![|825](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250226234958082.png)

- 自定义注解 AutoFill，用于标识需要进行公共字段自动填充的方法 
- 自定义切面类 AutoFillAspect，统一拦截加入了 AutoFill 注解的方法，通过反射为公共字段赋值 
- 在 Mapper 的方法上加入 AutoFill 注解  

技术点：枚举、注解、AOP、反射

在 sky-server 中创建包 `annotation` 用来存放自定义注解。并且创建 `aspect` 包用来定义切面。
```java
@Target({ElementType.METHOD})  
@Retention(RetentionPolicy.RUNTIME)  
public @interface AutoFill {  
    // 数据库操作类型，UPDATE INSERT  
    OperationType value();  
}
```

其中，数据库操作类型定义在 `sky-take-out/sky-common/src/main/java/com/sky/enumeration/OperationType.java`
```java
/**  
 * 数据库操作类型  
 */  
public enum OperationType {  
  
    /**  
     * 更新操作  
     */  
    UPDATE,  
  
    /**  
     * 插入操作  
     */  
    INSERT  
  
}
```

`aspect` 包下创建 `AutoFillAspect.java` 切面类
```java
@Aspect  
@Component  
@Slf4j  
public class AutoFillAspect {  
    /**  
     * 切入点  
     */  
    @Pointcut("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")  
    public void autoFillPointCut() {}  
  
    /**  
     * 前置通知，在数据库中插入/更新数据之前，对数据进行填充  
     */  
    @Before("autoFillPointCut()")  
    public void autoFill(JoinPoint joinPoint) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {  
        // 获取到当前被拦截的方法上数据库操作类型  
        MethodSignature signature = (MethodSignature) joinPoint.getSignature(); // 方法签名对象  
        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class); // 获得方法上的注解对象  
        OperationType operationType = autoFill.value(); // 获取数据库操作类型  
  
        // 获取到当前被拦截的方法的参数 -- 实体对象  
        Object[] args = joinPoint.getArgs();  
  
        if(args == null || args.length == 0) {  
            return ;  
        }  
  
        Object entity = args[0];  
  
        // 准备赋值的数据  
        LocalDateTime now = LocalDateTime.now();  
        Long currentId = BaseContext.getCurrentId();  
  
        // 根据当前不同的操作类型，为对应的属性通过反射来赋值  
        if(operationType == OperationType.INSERT) {  
            Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);  
            Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);  
            Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);  
            Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);  
  
            // 通过反射为对应的属性赋值  
            setCreateTime.invoke(entity, now);  
            setCreateUser.invoke(entity, currentId);  
            setUpdateTime.invoke(entity, now);  
            setUpdateUser.invoke(entity, currentId);  
        } else if(operationType == OperationType.UPDATE) {  
            Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);  
            Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);  
  
            // 通过反射为对应的属性赋值  
            setUpdateTime.invoke(entity, now);  
            setUpdateUser.invoke(entity, currentId);  
        }  
    }  
}
```

公共字段自动填充方法名相关常量定义在 `sky-take-out/sky-common/src/main/java/com/sky/constant/AutoFillConstant.java`
```java
/**  
 * 公共字段自动填充相关常量  
 */  
public class AutoFillConstant {  
    /**  
     * 实体类中的方法名称  
     */  
    public static final String SET_CREATE_TIME = "setCreateTime";  
    public static final String SET_UPDATE_TIME = "setUpdateTime";  
    public static final String SET_CREATE_USER = "setCreateUser";  
    public static final String SET_UPDATE_USER = "setUpdateUser";  
}
```

然后在 Mapper 加上注解。
比如 `EmployeeMapper` 的 insert 和 update 方法上都加上注解
```java
@AutoFill(value = OperationType.INSERT)  
void insert(Employee employee);

@AutoFill(value = OperationType.UPDATE)  
void update(Employee employee);
```

相应的 Service 实现里面的 update 和 insert 方法中之前人工填充这些值的代码也可以删掉了。

## 菜品模块
业务规则：
- 菜品名称必须是唯一的 
- 菜品必须属于某个分类下，不能单独存在 
- 新增菜品时可以根据情况选择菜品的口味 
- 每个菜品必须对应一张图片

### 数据表设计
![|725](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250301000246304.png)

### 文件上传
![|700](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250228235804222.png)

![|500](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250301125313522.png)

```ad-warning
我使用的是最新版的 oss 的 api。还需要修改 pom.xml
```
#### 准备
`pom.xml` 中修改依赖版本号为：
```xml
<aliyun.sdk.oss>3.17.4</aliyun.sdk.oss>  
<activation>1.1.1</activation>  
<jaxb-runtime>2.3.3</jaxb-runtime>
```

依赖：
```xml
<dependency>  
    <groupId>com.aliyun.oss</groupId>  
    <artifactId>aliyun-sdk-oss</artifactId>  
    <version>${aliyun.sdk.oss}</version>  
</dependency>  
  
<dependency>  
    <groupId>javax.xml.bind</groupId>  
    <artifactId>jaxb-api</artifactId>  
    <version>${jaxb-api}</version>  
</dependency>  
  
<dependency>  
    <groupId>javax.activation</groupId>  
    <artifactId>activation</artifactId>  
    <version>${activation}</version>  
</dependency>  
  
<dependency>  
    <groupId>org.glassfish.jaxb</groupId>  
    <artifactId>jaxb-runtime</artifactId>  
    <version>${jaxb-runtime}</version>  
</dependency>
```

`OSS_ACCESS_KEY_ID` 和 `OSS_ACCESS_KEY_SECRET` 配置在系统环境变量。
![|450](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250301130108021.png)

`sky-take-out/sky-common/src/main/java/com/sky/properties/AliOssProperties.java`
```java
@Component  
@ConfigurationProperties(prefix = "sky.alioss")  
@Data  
public class AliOssProperties {  
  
    private String endpoint;  
    // private String accessKeyId;  
    // private String accessKeySecret;  
    private String bucketName;  
  	private String region;
}
```

在 `application.yml` 配置文件中添加配置(springboot 可以将这里的 - 转换为驼峰命名法)：
```yml
sky:    
  alioss:  
    endpoint: ${sky.alioss.endpoint}  
	bucket-name: ${sky.alioss.bucket-name}
	region: ${sky.alioss.region}
```

实际值在 `application-dev.yml` 配置文件中配置实际值
```yml
sky: 
	alioss:  
	  endpoint:  
	  bucket-name:
	  region: 
```

我的参考配置
```java
sky: 
	alioss:  
	  endpoint: "https://oss-cn-guangzhou.aliyuncs.com"
	  bucket-name:
	  region: cn-guangzhou
```

`sky-take-out/sky-common/src/main/java/com/sky/utils/AliOssUtil.java`
```java
import com.aliyun.oss.ClientBuilderConfiguration;  
import com.aliyun.oss.OSS;  
import com.aliyun.oss.OSSClientBuilder;  
import com.aliyun.oss.common.auth.CredentialsProviderFactory;  
import com.aliyun.oss.common.auth.EnvironmentVariableCredentialsProvider;  
import com.aliyun.oss.common.comm.SignVersion;  
import com.aliyuncs.exceptions.ClientException;  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import org.springframework.web.multipart.MultipartFile;  
  
import java.io.IOException;  
import java.io.InputStream;  
import java.util.UUID;  
  
/**  
 * 阿里云 OSS 工具类  
 */  
@Data  
@AllArgsConstructor  
public class AliOssUtil {  
  
    private String endpoint;  
    private String bucketName;  
    private String region;  
  
    /**  
     * 实现上传图片到OSS  
     */  
    public String upload(MultipartFile file) throws IOException {  
        // 获取上传的文件的输入流  
        InputStream inputStream = file.getInputStream();  
        EnvironmentVariableCredentialsProvider credentialsProvider = null;  
        try {  
            credentialsProvider = CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider();  
        } catch (ClientException e) {  
            throw new RuntimeException(e);  
        }  
        // 避免文件覆盖  
        String originalFilename = file.getOriginalFilename();  
        String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf("."));  
  
        //上传文件到 OSS        ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration();  
        clientBuilderConfiguration.setSignatureVersion(SignVersion.V4);  
        OSS ossClient = OSSClientBuilder.create()  
                .endpoint(endpoint)  
                .credentialsProvider(credentialsProvider)  
                .clientConfiguration(clientBuilderConfiguration)  
                .region(region)  
                .build();  
  
        // 定义上传文件的目录和文件名  
        String objectName = "sky-take-out/" + fileName;  
        ossClient.putObject(bucketName, objectName, inputStream);  
  
        //文件访问路径  
        String url = endpoint.split("//")[0] + "//" + bucketName + "." + endpoint.split("//")[1] + "/" + objectName;  
        // 关闭ossClient  
        ossClient.shutdown();  
        return url;// 把上传到oss的路径返回  
    }  
  
}
}```

还要通过配置类的方式实例化属性，`sky-take-out/sky-server/src/main/java/com/sky/config/OssConfiguration.java`
```java
@Configuration  
public class OssConfiguration {  
    @Bean  
    @ConditionalOnMissingBean // 没有这个 Bean 的时候再去创建  
    public AliOssUtil aliOssUtil(AliOssProperties aliOssProperties) {  
        return new AliOssUtil(aliOssProperties.getEndpoint(),  
                aliOssProperties.getBucketName(),  
                aliOssProperties.getRegion());  
    }  
}
```

创建一个 CommonController。文件最后上传成功返回的是一个 url 地址，所以返回值是 `String` 类型。
```java
@RestController  
@RequestMapping("/admin/common")  
@Api(tags = "通用接口")  
@Slf4j  
public class CommonController {  
  
    @Autowired  
    private AliOssUtil aliOssUtil;  
  
    /**  
     * 文件上传  
     * @param file  
     * @return  
     */  
    @PostMapping("/upload")  
    @ApiOperation("文件上传")  
    public Result<String> upload(MultipartFile file) {  
        try {  
            String path = aliOssUtil.upload(file);  
            return Result.success(path);  
        } catch (IOException e) {  
            log.error("文件上传失败: {}", e);  
        }  
  
        return null;  
    }  
}
```

最后上传的文件会在这个目录下
![|675](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250301140812719.png)

### 新增菜品
![|700](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250301145059714.png)

新增菜品传过来的数据项比较多，封装到 `DishDTO` 当中
```java
@Data  
public class DishDTO implements Serializable {  
  
    private Long id;  
    //菜品名称  
    private String name;  
    //菜品分类id  
    private Long categoryId;  
    //菜品价格  
    private BigDecimal price;  
    //图片  
    private String image;  
    //描述信息  
    private String description;  
    //0 停售 1 起售  
    private Integer status;  
    //口味  
    private List<DishFlavor> flavors = new ArrayList<>();  
  
}
```

#### Controller 层
由于传过来的是 json 格式的数据，需要加上 `@RequestBody` 注解。同时，需要注意的是我们要修改的不仅仅是菜品表，还有口味。
`DishController`
```java
@RestController  
@RequestMapping("/admin/dish")  
@Api(tags = "菜品相关接口")  
public class DishController {  
  
    @Autowired  
    private DishService dishService;  
  
    /**  
     * 新增菜品  
     * @param dishDTO  
     * @return  
     */  
    @PostMapping  
    @ApiOperation("新增菜品")  
    public Result save(@RequestBody DishDTO dishDTO) {  
        dishService.saveWithFlavor(dishDTO);  
        return Result.success();  
    }  
}
```

#### Service 层
由于要操控两张表，所以要用事务管理，加上 `@Transactional` 注解

`DishServiceImpl`
```java
@Service  
public class DishServiceImpl implements DishService {  
  
    @Autowired  
    private DishMapper dishMapper;  
  
    @Autowired  
    private DishFlavorMapper dishFlavorMapper;  
  
    /**  
     * 新增菜品和对应的口味数据  
     * @param dishDTO  
     */  
    @Override  
    @Transactional    public void saveWithFlavor(DishDTO dishDTO) {  
  
        Dish dish = new Dish();  
        BeanUtils.copyProperties(dishDTO, dish);  
  
        // 向菜品表插入 1 条数据  
        dishMapper.insert(dish);  
  
        // 获取菜品的 id        Long dishId = dish.getId();  
  
        // 先获取口味集合  
        List<DishFlavor> flavors = dishDTO.getFlavors();  
        if(flavors != null && flavors.size() > 0) {  
  
            flavors.forEach(dishFlavor -> {  
                dishFlavor.setDishId(dishId);  
            });  
  
            // 向口味表插入 n 条数据  
            dishFlavorMapper.insertBatch(flavors);  
        }  
    }  
}
```

#### Mapper 层
`DishMapper` 在前面已经创建过了，所以在原先基础上增加就行
```java
/**  
 * 插入菜品数据  
 * @param dish  
 */  
@AutoFill(value = OperationType.INSERT)  
void insert(Dish dish);
```

`DishFlavorMapper`
```java
@Mapper  
public interface DishFlavorMapper {  
  
    /**  
     * 批量插入口味数据  
     * @param flavors  
     */  
    void insertBatch(List<DishFlavor> flavors);  
}
```

`DishMapper.xml`
```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >  
<mapper namespace="com.sky.mapper.DishMapper">  
  
    <insert id="insert">  
        insert into dish (name, category_id, price, image, description, status, create_time, update_time, create_user, update_user)  
        values        (#{name}, #{categoryId}, #{price}, #{image}, #{description}, #{status}, #{createTime}, #{updateTime}, #{createUser}, #{updateUser})    </insert>  
</mapper>
```

`DishFlavorMapper.xml`
```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >  
<mapper namespace="com.sky.mapper.DishFlavorMapper">  
  
    <insert id="insertBatch">  
        insert into dish_flavor (dish_id, name, value)  
        values        <foreach collection="flavors" item="df" separator=",">  
            (#{df.dishId}, #{df.name}, #{df.value})  
        </foreach>  
    </insert>  
</mapper>
```

要注意的是，dishId 我们应该如何获取？在前面插入了 dish 之后会生成一个 id，我们需要 insert 语句之后将产生的主键值返回。
`DishMapper.xml` 改为
```xml
<insert id="insert" useGeneratedKeys="true" keyProperty="id">  
    insert into dish (name, category_id, price, image, description, status, create_time, update_time, create_user, update_user)  
    values    (#{name}, #{categoryId}, #{price}, #{image}, #{description}, #{status}, #{createTime}, #{updateTime}, #{createUser}, #{updateUser})</insert>
```

### 菜品分页查询
#### 需求分析
- 根据页码展示菜品信息
- 每页展示 10 条数据
- 分页查询时可以根据需要输入菜品名称、菜品分类、菜品状态进行查询

![|950](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250302131637425.png)
要注意的是，`CategoryName` 在菜品表里面并没有，菜品表里面只是存了分类的 ID，所以说分类的名称要到分类表里面去查。

#### DTO 设计
`DishPageQueryDTO`
```java
@Data  
public class DishPageQueryDTO implements Serializable {  
  
    private int page;  
  
    private int pageSize;  
  
    private String name;  
  
    //分类id  
    private Integer categoryId;  
  
    //状态 0表示禁用 1表示启用  
    private Integer status;  
  
}
```

#### VO 设计
由于返回的里面有 `CategoryName`，所以又设计了一个 VO
```java
@Data  
@Builder  
@NoArgsConstructor  
@AllArgsConstructor  
public class DishVO implements Serializable {  
  
    private Long id;  
    //菜品名称  
    private String name;  
    //菜品分类id  
    private Long categoryId;  
    //菜品价格  
    private BigDecimal price;  
    //图片  
    private String image;  
    //描述信息  
    private String description;  
    //0 停售 1 起售  
    private Integer status;  
    //更新时间  
    private LocalDateTime updateTime;  
    //分类名称  
    private String categoryName;  
    //菜品关联的口味  
    private List<DishFlavor> flavors = new ArrayList<>();  
}
```

#### Controller 层
```java
@GetMapping("/page")  
@ApiOperation("菜品分页查询")  
public Result<PageResult> page(DishPageQueryDTO dishPageQueryDTO) {  
  
    PageResult pageResult = dishService.pageQuery(dishPageQueryDTO);  
  
    return Result.success(pageResult);  
}
```

#### Service 层
```java
@Override  
public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) {  
    PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());  
    Page<DishVO> page = dishMapper.pageQuery(dishPageQueryDTO);  
  
    return new PageResult(page.getTotal(), page.getResult());  
}
```

#### Mapper 层
```java
Page<DishVO> pageQuery(DishPageQueryDTO dishPageQueryDTO);
```

xml 映射文件中编写动态 SQL。使用[[多表查询#左外连接]]
```xml
<select id="pageQuery" resultType="com.sky.vo.DishVO">  
    select d.*, c.name as categoryName  
    from dish d left join category c    on d.category_id = c.id    <where>  
        <if test="name != null">  
            and d.name like concat('%', #{name}, '%')  
        </if>  
        <if test="categoryId != null">  
            and d.category_id = #{categoryId}  
        </if>  
        <if test="status != null">  
            and d.status = #{status}  
        </if>  
    </where>  
    order by d.create_time desc  
</select>
```

### 删除菜品
#### 需求分析
- 可以一次删除一个菜品，也可以批量删除菜品
- 起售中的菜品不能删除
- 被套餐关联的菜品不能删除
- 删除菜品后，关联的口味数据也需要删除掉

![|750](https://typora-birdy.oss-cn-guangzhou.aliyuncs.com/20250302134554061.png)

删除操作一共会涉及到三张表：
- dish 表
- dish_flavor 表
- setmeal_dish 表

#### Controller 层
ids 实际上传过来是一个字符串，不过由很多 id 组成。我们可以通过注解的方式，交给 SpringMVC，来帮我们动态地解析字符串。
```java
@DeleteMapping  
@ApiOperation("批量删除菜品")  
public Result delete(@RequestParam List<Long> ids) {  
    dishService.deleteBatch(ids);  
    return Result.success();  
}
```

#### Service 层
由于涉及到多个数据表的操作，要加上事务注解
```java
@Autowired  
private SetmealDishMapper setmealDishMapper;

@Override  
@Transactional
public void deleteBatch(List<Long> ids) {  
    // 判断当前菜品是否能够删除 -- 是否存在起售中的菜品  
    for(Long id : ids) {  
        Dish dish = dishMapper.getById(id);  
        if(dish.getStatus() == StatusConstant.ENABLE) {  
            // 当前菜品处于起售中，不能删除  
            throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);  
        }  
    }  
  
    // 判断当前菜品是否被套餐关联了  
    List<Long> setmealIds = setmealDishMapper.getSetmealIdsByDishIds(ids);  
    if(setmealIds != null && setmealIds.size() > 0) {  
        // 当前菜品被套餐关联了，不能删除  
        throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);  
    }  
  
    // 删除菜品表的菜品数据  
    for(Long id : ids) {  
        dishMapper.deleteById(id);  
        // 删除菜品关联的口味数据  
        dishFlavorMapper.deleteByDishId(id);  
    }  
}
```

```ad-warning
后面有进一步的优化
```

#### Mapper 层
创建一个 `SetmealDishMapper`
```java
List<Long> getSetmealIdsByDishIds(List<Long> dishIds);
```

查询套餐 ID 的 SQL 语句类似于这样。我们使用动态 SQL 编写
```mysql
select setmeal_id from setmeal_dish where dish_id in (1, 2, 3, 4)
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >  
<mapper namespace="com.sky.mapper.SetmealDishMapper">  
  
    <select id="getSetmealIdsByDishIds" resultType="java.lang.Long">  
        select setmeal_id from setmeal_dish  
        where dish_id in        <foreach collection="dishIds" item="dishId" separator=","  
                 open="(" close=")">  
            #{dishId}  
        </foreach>  
    </select>  
</mapper>
```

在 `DishFlavorMapper` 中
```java
@Delete("delete from dish_flavor where dish_id = #{dishId}")  
void deleteByDishId(Long dishId);
```

`DishMapper`
```java
@Select("select * from dish where id = #{id}")  
Dish getById(Long id);  
  
@Delete("delete from dish where id = #{id}")  
void deleteById(Long id);
```

#### 代码优化
Service 层原先遍历删除菜品和关联的口味数据，如果数据量很大，则会导致遍历次数多，相应的 SQL 语句次数也会变多，效率不高。
```java
//        for(Long id : ids) {  
//            dishMapper.deleteById(id);  
//            // 删除菜品关联的口味数据  
//            dishFlavorMapper.deleteByDishId(id);  
//        }  
  
// 根据菜品 id 集合批量删除菜品数据  
dishMapper.deleteByIds(ids);  

// 根据菜品 id 集合批量删除关联的口味数据  
dishFlavorMapper.deleteByDishIds(ids);
```

`DishMapper`
```java
<delete id="deleteByIds">  
    delete from dish where id in  
    <foreach collection="ids" open="(" close=")" separator="," item="id">  
        #{id}  
    </foreach>  
</delete>
```

`DishFlavorMapper`
```java
<delete id="deleteByDishIds">  
    delete from dish_flavor where dish_id in  
    <foreach collection="dishIds" item="dishId" open="(" close=")" separator=",">  
        #{dishId}  
    </foreach>  
</delete>
```

### 修改菜品
#### 需求分析
- 根据 id 查询菜品
- 根据类型查询分类
- 文件上传
- 修改菜品
#### Controller 层
`DishVO` 中包含了口味数据，所以返回的应该是 DishVO
```java
@Data  
@Builder  
@NoArgsConstructor  
@AllArgsConstructor  
public class DishVO implements Serializable {  
  
    private Long id;  
    //菜品名称  
    private String name;  
    //菜品分类id  
    private Long categoryId;  
    //菜品价格  
    private BigDecimal price;  
    //图片  
    private String image;  
    //描述信息  
    private String description;  
    //0 停售 1 起售  
    private Integer status;  
    //更新时间  
    private LocalDateTime updateTime;  
    //分类名称  
    private String categoryName;  
    //菜品关联的口味  
    private List<DishFlavor> flavors = new ArrayList<>();  
  
    //private Integer copies;  
}
```
修改菜品的界面要有页面回显，还要显示出菜品的口味，所以需要用到两张表。在 `DishController` 下
```java
@GetMapping("/{id}")  
@ApiOperation("根据id查询菜品")  
public Result<DishVO> getById(@PathVariable Long id) {  
    DishVO dishVO = dishService.getByIdWithFlavor(id);  
    return Result.success(dishVO);  
}

@PutMapping  
@ApiOperation("修改菜品")  
public Result update(@RequestBody DishDTO dishDTO) {  
    dishService.updateWithFlavor(dishDTO);  
    return Result.success();  
}
```
#### Service 层
```java
@Override  
public DishVO getByIdWithFlavor(Long id) {  
    // 根据 id 查询菜品数据  
    Dish dish = dishMapper.getById(id);  
  
    // 根据菜品 id 查询口味数据  
    List<DishFlavor> dishFlavors = dishFlavorMapper.getByDishId(id);  
  
    // 将查询结果封装到 DishVO    DishVO dishVO = new DishVO();  
    BeanUtils.copyProperties(dish, dishVO);  
    dishVO.setFlavors(dishFlavors);  
  
    return dishVO;  
}  

@Override  
public void updateWithFlavor(DishDTO dishDTO) {  
    Dish dish = new Dish();  
    BeanUtils.copyProperties(dishDTO, dish);  
  
    // 修改菜品表基本信息  
    dishMapper.update(dish);  
  
    // 删除原有的口味数据  
    dishFlavorMapper.deleteByDishId(dishDTO.getId());  
  
    // 重新插入口味数据  
    List<DishFlavor> flavors = dishDTO.getFlavors();  
  
    if(flavors != null && flavors.size() > 0) {  
        flavors.forEach(dishFlavor -> {  
            dishFlavor.setDishId(dishDTO.getId());  
        });  
        dishFlavorMapper.insertBatch(flavors);  
    }  
}
```
#### Mapper 层
`DishMapper` 下
```java
@AutoFill(value = OperationType.UPDATE)  
void update(Dish dish);
```

```xml
<update id="update">  
    update dish  
    <set>  
        <if test="name != null">name = #{name},</if>  
        <if test="categoryId != null">category_id = #{categoryId},</if>  
        <if test="price != null">price = #{price},</if>  
        <if test="image != null">image = #{image},</if>  
        <if test="description != null">description = #{description},</if>  
        <if test="status != null">status = #{status},</if>  
        <if test="updateTime != null">update_time = #{updateTime},</if>  
        <if test="updateUser != null">update_user = #{updateUser},</if>  
    </set>  
    where id = #{id}  
</update>
```

`DishFlavorMapper` 下
```java
@Select("select * from dish_flavor where dish_id = #{dishId}")  
List<DishFlavor> getByDishId(Long dishId);
```

## 套餐模块
- 新增套餐
- 套餐分页查询
- 删除套餐
- 修改套餐 
- 起售停售套餐

### 新增套餐
#### 需求分析
- 套餐名称唯一
- 套餐必须属于某个分类
- 套餐必须包含菜品
- 名称、分类、价格、图片为必填项
- 添加菜品窗口需要根据分类类型来展示菜品
- 新增的套餐默认为停售状态

#### 接口设计
- 根据类型查询分类（已完成）
- 根据分类id查询菜品
- 图片上传（已完成）
- 新增套餐

#### Controller 层
DishController
```java
/**  
 * 根据分类id查询菜品  
 * @param categoryId  
 * @return  
 */  
@GetMapping("/list")  
@ApiOperation("根据分类id查询菜品")  
public Result<List<Dish>> list(Long categoryId) {  
    List<Dish> list = dishService.list(categoryId);  
    return Result.success(list);  
}
```

新建 SetmealController
```java
@RestController  
@RequestMapping("/admin/setmeal")  
@Api(tags = "套餐相关接口")  
@Slf4j  
public class SetmealController {  
    @Autowired  
    private SetmealService setmealService;  
  
    @PostMapping  
    @ApiOperation("新增套餐")  
    public Result save(@RequestBody SetmealDTO setmealDTO) {  
        setmealService.saveWithDish(setmealDTO);  
        return Result.success();  
    }}
```

#### Service 层 
```java
/**  
 * 根据分类id查询菜品  
 * @param categoryId  
 * @return  
 */  
@GetMapping("/list")  
@ApiOperation("根据分类id查询菜品")  
public Result<List<Dish>> list(Long categoryId) {  
    List<Dish> list = dishService.list(categoryId);  
    return Result.success(list);  
}
```

#### Mapper 层
```java
/**  
 * 根据条件查询菜品数据  
 * @param dish  
 * @return  
 */  
List<Dish> list(Dish dish);
```

```xml
<select id="list" resultType="com.sky.entity.Dish">  
    select * from dish  
    <where>  
        <if test="name != null">  
            and name like concat('%',#{name},'%')  
        </if>  
        <if test="categoryId != null">  
            and category_id = #{categoryId}  
        </if>  
        <if test="status != null">  
            and status = #{status}  
        </if>  
    </where>  
    order by create_time desc  
</select>
```

## 店铺营业状态配置
### Redis 配置
dev 配置文件下
```yml
sky:  
  redis:  
    host: localhost  
    port: 6379  
    database: 10
```

```yml
spring:  
  redis:  
    host: ${sky.redis.host}  
    port: ${sky.redis.port}  
    database: ${sky.redis.database}
```


```java
@Configuration  
@Slf4j  
public class RedisConfiguration {  
    @Bean  
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) {  
        RedisTemplate redisTemplate = new RedisTemplate();  
        // 设置 redis 的连接工厂对象  
        redisTemplate.setConnectionFactory(redisConnectionFactory);  
        // 设置 redis key 的序列化器  
        redisTemplate.setKeySerializer(new StringRedisSerializer());  
        return redisTemplate;  
    }  
}
```

### 需求分析
- 设置营业状态
- 管理端查询营业状态
- 用户端查询状态

由于本项目约定:
- 管理端发出的请求，统一用 `/admin` 作为前缀
- 用户端发出的请求，统一使用 `/user` 作为前缀

所以，需要两个 controller

### Controller 层
#### 管理端
在管理端 `controller/admin` 包下
由于传入的是路径参数，所以要加上 `@PathVariable`
```java
@RestController("adminShopController")  
@RequestMapping("/admin/shop")  
@Api(tags = "店铺相关接口")  
public class ShopController {  
  
    public static final String KEY = "SHOP_STATUS";  
  
    @Autowired  
    private RedisTemplate redisTemplate;  

    @PutMapping("/{status}")  
    @ApiOperation("设置店铺营业状态")  
    public Result setStatus(@PathVariable Integer status) {  
        redisTemplate.opsForValue().set(KEY, status);  
        return Result.success();  
    }  
  
    @GetMapping("/status")  
    @ApiOperation("获取店铺营业状态")  
    public Result<Integer> getStatus() {  
        Integer status = (Integer) redisTemplate.opsForValue().get(KEY);  
  
        return Result.success(status);  
    }  
}
```

#### 用户端
只有查询功能。
`controller/user` 包下
```java
@RestController("userShopController")  
@RequestMapping("/user/shop")  
@Api(tags = "店铺相关接口")  
@Slf4j  
public class ShopController {  
  
    public static final String KEY = "SHOP_STATUS";  
  
    @Autowired  
    private RedisTemplate redisTemplate;  
  
    @GetMapping("/status")  
    @ApiOperation("获取店铺营业状态")  
    public Result<Integer> getStatus() {  
        Integer status = (Integer) redisTemplate.opsForValue().get(KEY);  
  
        return Result.success(status);  
    }  
}
```

#### 改进
但是它们两个 controller 都叫做 `ShopController` 的话就会有冲突，
```ad-warning
spring 默认是以类名将第一个字母改成小写, 当作 bean 的名称
```

所以我们手动设置下 bean 的名字
```java
@RestController("userShopController")
```

```java
@RestController("adminShopController")
```

`WebMvcConfiguration` 下将原先的 knife4j 生成接口文档代码改为：
```java
@Bean  
public Docket docket1() {  
    ApiInfo apiInfo = new ApiInfoBuilder()  
            .title("苍穹外卖项目接口文档")  
            .version("2.0")  
            .description("苍穹外卖项目接口文档")  
            .build();  
    Docket docket = new Docket(DocumentationType.SWAGGER_2)  
            .groupName("管理端接口")  
            .apiInfo(apiInfo)  
            .select()  
            .apis(RequestHandlerSelectors.basePackage("com.sky.controller.admin"))  
            .paths(PathSelectors.any())  
            .build();  
    return docket;  
}  
  
@Bean  
public Docket docket2() {  
    ApiInfo apiInfo = new ApiInfoBuilder()  
            .title("苍穹外卖项目接口文档")  
            .version("2.0")  
            .description("苍穹外卖项目接口文档")  
            .build();  
    Docket docket = new Docket(DocumentationType.SWAGGER_2)  
            .groupName("用户端接口")  
            .apiInfo(apiInfo)  
            .select()  
            .apis(RequestHandlerSelectors.basePackage("com.sky.controller.user"))  
            .paths(PathSelectors.any())  
            .build();  
    return docket;  
}
```

通过控制扫描不同包，还有设置组别名字，可以将管理端接口页面和用户端接口页面分开。